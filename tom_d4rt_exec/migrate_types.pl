#!/usr/bin/perl -pi
# Phase 2/4: Replace analyzer type names with S-prefixed SAstNode equivalents
# Uses negative lookbehind to avoid double-prefixing
# Longest names first to avoid partial matches within the alternation

s/(?<!S)\b(PatternVariableDeclarationStatement|RedirectingConstructorInvocation|FunctionTypedFormalParameter|TopLevelVariableDeclaration|VariableDeclarationStatement|SuperConstructorInvocation|FunctionExpressionInvocation|ConstructorFieldInitializer|ForEachPartsWithDeclaration|ForEachPartsWithIdentifier|InstanceCreationExpression|ForPartsWithDeclarations|ExtensionTypeDeclaration|InterpolationExpression|AssignedVariablePattern|RecordTypeAnnotation|VariableDeclarationList|DeclaredVariablePattern|ForPartsWithExpression|ConstructorDeclaration|ConstructorReference|EnumConstantDeclaration|DefaultFormalParameter|ExpressionFunctionBody|SimpleFormalParameter|FieldFormalParameter|SuperFormalParameter|AssignmentExpression|ConditionalExpression|InterpolationString|SimpleStringLiteral|FunctionDeclaration|FunctionExpression|FunctionReference|GenericFunctionType|ExtensionDeclaration|ConstructorName|ExpressionStatement|StringInterpolation|AdjacentStrings|BinaryExpression|BlockFunctionBody|EmptyFunctionBody|AwaitExpression|ParenthesizedExpression|PrefixedIdentifier|PostfixExpression|PrefixExpression|RethrowExpression|MethodDeclaration|MethodInvocation|VariableDeclaration|PatternAssignment|PatternFieldName|FieldDeclaration|ClassDeclaration|MixinDeclaration|EnumDeclaration|BreakStatement|CascadeExpression|IndexExpression|FormalParameterList|ForEachStatement|PropertyAccess|AssertInitializer|AssertStatement|BooleanLiteral|CompilationUnit|ContinueStatement|DoubleLiteral|EmptyStatement|ExportDirective|ImportDirective|PartDirective|PartOfDirective|IntegerLiteral|IsExpression|AsExpression|MapLiteralEntry|NamedExpression|CatchClause|DeclaredIdentifier|LabeledStatement|ReturnStatement|SetOrMapLiteral|SimpleIdentifier|SpreadElement|ShowCombinator|HideCombinator|SwitchCase|SwitchDefault|SwitchStatement|SwitchExpression|SwitchExpressionCase|SwitchPatternCase|ThrowExpression|TryStatement|TypeParameterList|WhileStatement|DoStatement|ForElement|ForStatement|IfElement|IfStatement|Block|ListLiteral|MapPattern|ListPattern|RecordLiteral|RecordPattern|ObjectPattern|CastPattern|ConstantPattern|LogicalAndPattern|LogicalOrPattern|MapPatternEntry|RelationalPattern|RestPatternElement|WildcardPattern|NullLiteral|ParenthesizedPattern|NullAssertPattern|NullCheckPattern|SuperExpression|ThisExpression|GuardedPattern|WhenClause|CaseClause|YieldStatement|NamedType|TypeArgumentList|TypeParameter|Label|Comment|Annotation)\b/S$1/g;

# Also handle: GeneralizingAstVisitor -> GeneralizingSAstVisitor, AstNode -> SAstNode
s/\bGeneralizingAstVisitor\b/GeneralizingSAstVisitor/g;
s/(?<!S)\bAstNode\b/SAstNode/g;

# NodeList<T> -> List<T> (NodeList is analyzer-specific)
s/\bNodeList\b/List/g;
