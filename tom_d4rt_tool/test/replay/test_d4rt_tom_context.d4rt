# D4rt Test Suite - Part 5: Context and Exception Classes
# Run with: d4rt -run-replay test_d4rt_tom_context.d4rt -test
# Tests context patterns and exception handling


# =============================================================================
# Test: TomException (6 tests)
# TomException takes: (key, defaultUserMessage, {optional params})
# =============================================================================

var exception = TomException('TEST_ERROR', 'Test error message');
verifyNotNull(exception, 'TomException created');
verifyEquals(exception.key, 'TEST_ERROR', 'Exception key');
verifyEquals(exception.defaultUserMessage, 'Test error message', 'Exception message');
verifyNotNull(exception.toString(), 'Exception toString');

var exceptionWithParams = TomException('ERR001', 'Error with code');
verifyEquals(exceptionWithParams.key, 'ERR001', 'Exception key as code');
verifyContains(exceptionWithParams.toString(), 'ERR001', 'Exception toString has key');
verifyContains(exceptionWithParams.toString(), 'Error with code', 'Exception toString has message');

# =============================================================================
# Test: Custom Context Class (5 tests)
# =============================================================================

.start-define
class AppContext {
  final String userId;
  final String sessionId;
  final Map<String, dynamic> data;
  
  AppContext({
    required this.userId, 
    required this.sessionId,
    Map<String, dynamic>? data,
  }) : data = data ?? {};
  
  T? get<T>(String key) => data[key] as T?;
  
  void set(String key, dynamic value) {
    data[key] = value;
  }
}
.end

var ctx = AppContext(userId: 'user-123', sessionId: 'sess-456');
verifyEquals(ctx.userId, 'user-123', 'Context user ID');
verifyEquals(ctx.sessionId, 'sess-456', 'Context session ID');

ctx.set('theme', 'dark');
verifyEquals(ctx.get<String>('theme'), 'dark', 'Context get/set');

ctx.set('count', 42);
verifyEquals(ctx.get<int>('count'), 42, 'Context get int');

# =============================================================================
# Test: Key-Value Store Pattern (5 tests)
# =============================================================================

.start-define
class KeyValueStore {
  final Map<String, dynamic> _store = {};
  
  void put(String key, dynamic value) {
    _store[key] = value;
  }
  
  dynamic get(String key) => _store[key];
  
  bool contains(String key) => _store.containsKey(key);
  
  void remove(String key) => _store.remove(key);
  
  int get length => _store.length;
}
.end

var store = KeyValueStore();
verifyEquals(store.length, 0, 'Store initially empty');

store.put('name', 'Test');
verifyEquals(store.get('name'), 'Test', 'Store put and get');
verifyEquals(store.length, 1, 'Store has one item');

verify(store.contains('name'), 'Store contains key');

store.remove('name');
verifyEquals(store.length, 0, 'Store empty after remove');

# =============================================================================
# Test: Exception with Details (4 tests)
# =============================================================================

var detailEx = TomException('OP_FAIL', 'Operation failed');
verifyEquals(detailEx.key, 'OP_FAIL', 'Detail exception key');
verifyContains(detailEx.defaultUserMessage, 'Operation failed', 'Detail exception message');

var detailEx2 = TomException('ANOTHER', 'Another failure');
verifyEquals(detailEx2.key, 'ANOTHER', 'Second exception key');
verifyNotNull(detailEx2.toString(), 'Second exception toString');

# =============================================================================
# Summary
# =============================================================================

testSummary();
